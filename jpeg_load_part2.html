<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Fire-eggs.GitHub.io : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Windows JPEG Load Performance - Part II</title>
  </head>

<body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/fire-eggs">View on GitHub</a>
          <h1 id="project_title">Windows JPEG Load Performance</h1>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

<h3>TL;DR:</h3>
When Natively loading JPEGs on Windows, the libJpeg-turbo library is on average the fastest.
<p>

<h3>Measuring More Libraries</h3>
<p>See <a href="http://fire-eggs.github.io/jpeg_load.html">Part 1</a> to see the original libraries / methodology.</p>
<p>In this part I measured two more JPEG decoders:</p>
<ol>
<li>JPEGLib V9b</li>
<li>LibJpeg-Turbo</li>
</ol>

<h4>JPEGLib V9b</h4>

<h4>LibJpeg-Turbo</h4>

<h3>Testing</h3>
<p>
  Here are the results. These are internal timings only, average of three runs. All times in seconds.
</p>

<table style="margin:0px auto; width:400px">
  <tr><td></td><td colspan="2">Quick</td><td colspan="2">Local</td><td colspan="2">Network</td></tr>
  <tr><td>Which</td><td>Load</td><td>PHash</td><td>Load</td><td>PHash</td><td>Load</td><td>PHash</td></tr>
  <tr><td>Jpeg 6.2</td><td>2.6</td><td></td><td>109.7</td><td></td><td>169.1</td><td></td></tr>
  <tr><td>GDI+</td>    <td>1.1</td><td></td><td>50.2</td><td></td><td>227.4</td><td></td></tr>
  <tr><td>WIC</td>     <td>1.0</td><td></td><td>46.4</td><td></td><td>170.3</td><td></td></tr>
  <tr><td>Jpeg 9b</td> <td>1.3</td><td></td><td>54.0</td><td></td><td>158.7</td><td></td></tr>
  <tr><td>Turbo</td>   <td>0.7</td><td></td><td>33.0</td><td></td><td>154.3</td><td></td></tr>
</table>

<ul><li><strong>Quick:</strong> Loading the small set of files from a local SSD.</li>
<li><strong>Local:</strong> Loading the large set of files from a local SSD.</li>
<li><strong>Network:</strong> Loading the large set of files from a remote HD.</li>
</ul>

<h3>Parallelism</h3>
<p>
As the application is CPU-bound, the next step is to use parallelism. The support for OpenMP is pretty straightforward to apply. The changes are:
</p>
<ol>
<li><code>#include "omp.h"</code></li>
<li>When iterating the file tree, gather the filenames into a list rather than process immediately.</li>
<li>Process the list of filenames in a loop, along with the <code>#pragma omp parallel for</code></li>
<li>Enable OpenMP settings in the project.</li>
</ol>
<p>This does add a dependency on vcomp120.dll.</p>
<p>And the numbers ...</p>
<img src="../images/AppRuntimes.png" alt="graph">
<p>

<table style="margin:0px auto; width:400px">
<tr><td>Which</td> <td>Local</td> <td>Parallel</td> <td>Network</td> <td>Parallel</td></tr>
<tr><td>WIC</td>   <td>264.78</td> <td>0</td>	    <td>391.45</td>	<td>0</td></tr>
<tr><td>Turbo</td> <td>251.66</td> <td>94.03</td>	<td>375.99</td>	<td>200.39</td></tr>
<tr><td>Jpeg9</td> <td>272.59</td> <td>101.41</td>	<td>380.78</td>	<td>195.28</td></tr>
<tr><td>GDI+</td>  <td>270.02</td> <td>101.39</td>	<td>442.02</td>	<td>208.19</td></tr>
<tr><td>Orig</td>  <td>328.42</td> <td>119.97</td>	<td>389.43</td>	<td>207.92</td></tr>
</table>

<h3>Conclusion</h3>

<h3>The Code</h3>
<strong>TBD</strong>

<h3>Resources</h3>
<strong>TBD</strong>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
</body>
</html>
